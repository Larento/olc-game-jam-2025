= Techcinal stuff

== Shape approximation

This game has many different odd shapes. Shapes are drawn as polygons. Each shape has to be confined in a **centroid circumcircle**. This is a circle which has its center coincident with the shape's centroid and its radius is exactly the farther distance from any polygon point to the centroid.

This way, we can have a sort of bounding circle for the shape, which is useful for constructing our levels in a balanced way - we know that the minimum possible distance between shapes will depend on how densely those centroid circumcircles are packed.

Because the shapes are "floating" (with no external forces acting on them) through space, they are supposed to be able rotate freely. Such a "floating" body rotates around their center of mass. We define the shapes to be of uniform density, therefore the center of physical mass is coincident with the center of its "geometric mass", a.k.a the shape's centroid.

Calculating the centroid for a given polygon is as easy as going through all of its points.

Our algorithm for generating different shape geometry using parametric equations is as follows:

1. Get sample points for the curve.
2. Calculate the centroid of resulting shape.
3. Find farthest point from centroid.
4. Translate and scale (in that order) all points to fit into the centroid circumcircle.


== Collision detection

Excalibur.js does not have a built-in mechanism for concave polygon collisions, only convex. This presents a challenge, because the shapes in the game can obviously be of any type.

In general the collider polygon should have much less detail than the actual polygon used for the graphic. These facts turn into a rough outline of what we ought to do to create colliders for our shapes:

1. Simplify the shape polygon. We have to make sure that the outer bounds are larger than the actual shape, otherwise we might have a spot where the collision is not present, but visually the shape is there. This causes confusion and distrust, which ultimately hurts the gamer.

2. Triangulate the polygon. This way we can build a complex collider. Simplification is key because we need the least amount of triangles to check for collision.

3. Build the complex collider.


== Level generation

Each level is generated by a seed and a difficulty level. The seed determines:

* distribution of size and type of shapes

The difficulty level influences:

* number of shapes (more difficult = less shapes)
* size of shapes (more difficult = smaller shapes)
* type of shapes (more difficult = more convex and thin shapes)
* linear and angular momentum of shapes (more difficult = faster moving and spinning shapes)

The difficulty level fully determines:

* level size (more difficult = larger level)
* centroid circumcircle packing density (more difficult = less dense)

Level generation algorithm:

1. Determine level size.
2. Generate grid of circles with packing density.
3. For each circle create a shape inside it.
4. Randomly choose shape along the edge of the level as the starting platform.
5. Randomly choose shape along the edge of the level opposite the starting platform. This is the exit platform - landing on it clears the level.
6. Position spider facing the direction of exit platform at the centroid of the starting platform.
7.